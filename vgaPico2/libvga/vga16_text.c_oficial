#include "vga16_text.h"
#include "glcdfont.c"
#include <string.h>
#include <stdlib.h>

// Estrutura completa com todos os membros
struct vga16_text_t {
    // Propriedades privadas
    uint16_t cursor_y;
    uint16_t cursor_x;
    uint8_t textsize;
    color_t textcolor;
    color_t textbgcolor;
    bool wrap;
    uint16_t width;
    uint16_t height;
    
    // Adicione aqui TODOS os membros que suas funções usam:
    uint8_t* vga_data_array;
    uint32_t txcount;
    uint16_t TOPMASK;
    uint16_t BOTTOMMASK;
    uint8_t tabspace;
    // ... adicione outros membros necessários
};

// Construtor
vga16_text_t* vga16_text_create(uint8_t mode) {
    vga16_text_t* vga = (vga16_text_t*)malloc(sizeof(vga16_text_t));
    if (!vga) return NULL;
    
    // Inicialização básica
    if(mode==0){    
        vga->cursor_x = 0 ;
        vga->cursor_y = 0 ;
        vga->textsize = 1 ;
        vga->textcolor = WHITE ;
        vga->textbgcolor = BLACK ;
        vga->wrap = true ;
        vga->width = 320;
        vga->height= 240;
    }
    else if(mode==1){    
        vga->cursor_x = 0 ;
        vga->cursor_y = 0 ;
        vga->textsize = 1 ;
        vga->textcolor = WHITE ;
        vga->textbgcolor = BLACK ;
        vga->wrap = true ;
        vga->width  = 640;
        vga->height = 480;
    } else {
        // Default values
        vga->cursor_x = 0 ;
        vga->cursor_y = 0 ;
        vga->textsize = 1 ;
        vga->textcolor = WHITE ;
        vga->textbgcolor = BLACK ;
        vga->wrap = true ;
    }


    return vga;
}

// Destrutor
void vga16_text_destroy(vga16_text_t* vga) {
    if (vga) {
        free(vga);
    }
}

// Implementações dos métodos (apenas esqueleto)
void vga16_text_init(vga16_text_t* vga, uint8_t mode) {
    // Seu código aqui
}

void vga16_text_clrscr(vga16_text_t* vga) {
  // clear the screen
  memset(&vga_data_array[0], 0, TXCOUNT) ;
  // reset cursor position
  vga->cursor_x = 0 ;
  vga->cursor_y = 0 ;
}

void vga16_text_pchar(vga16_text_t* vga, uint8_t c) {
    vga16_text_tft_write(vga,c);
}

void vga16_text_draw_pixel(vga16_text_t* vga, int16_t x, int16_t y, color_t color) {
    if((x > (vga->width-1)) | (x < 0) | (y > (vga->height-1)) | (y < 0) )
        return;

    int pixel = ((vga->width * y) + x) ;

    if (pixel & 1) {
        vga_data_array[pixel>>1] = (vga_data_array[pixel>>1] & vga->TOPMASK) | (color << 4) ;
    }
    else {
        vga_data_array[pixel>>1] = (vga_data_array[pixel>>1] & vga->BOTTOMMASK) | (color) ;
    }
}

void vga16_text_draw_hline(vga16_text_t* vga, int16_t x, int16_t y, int16_t w, color_t color) {
  if((x >= vga->width) || (y >= vga->height))
      return;
  if((x + w - 1) >= vga->width)
      w = vga->width  - x - 1;
  short both_color = color | (color<<4) ;
  if((x & 1)) {
    vga16_text_draw_pixel(vga,x,y,color);
    x++ ;
    w-- ;
  }
  if((w & 1)){
    vga16_text_draw_pixel(vga,x+w-1, y, color);
    w-- ;
  }
  int len = (w>>1)  ;
  if (len>0 && y<480 )
      memset(&vga_data_array[320*y+(x>>1)], both_color, len) ;
}

void vga16_text_fill_rect(vga16_text_t* vga, int16_t x, int16_t y, int16_t w, int16_t h, color_t color) {
    if((y + h - 1) >= vga->height) h = vga->height - y - 1;

    for(int j=y; j<(y+h); j++) {
      vga16_text_draw_hline(vga,x, j, w, color) ;
    }
}

void vga16_text_draw_char_interna(vga16_text_t* vga, int16_t x, int16_t y, uint8_t c,
                                 color_t color, color_t bg, uint8_t size) {
    char i, j;
    if((x >= vga->width)            || // Clip right
        (y >= vga->height)           || // Clip bottom
        ((x + 6 * size - 1) < 0) || // Clip left
        ((y + 8 * size - 1) < 0))   // Clip top
        return;

    short charWidth = 6 * size;
    short charHeight = 8 * size;
    // PRIMEIRO: Limpa a área completa do caractere
 //   vga16_text_fill_rect(vga,x, y, charWidth, charHeight, BLACK);

  for (i=0; i<6; i++ ) {
    unsigned char line;
    if (i == 5)
      line = 0x0;
    else
      line = pgm_read_byte(font+(c*5)+i);
    for ( j = 0; j<8; j++) {
      if (line & 0x1) {
        if (size == 1) // default size
          vga16_text_draw_pixel(vga,x+i, y+j, color);
        else {  // big size
          vga16_text_fill_rect(vga,x+(i*size), y+(j*size), size, size, color);
        }
      } else if (bg != color) {
        if (size == 1) // default size
          vga16_text_draw_pixel(vga,x+i, y+j, bg);
        else {  // big size
          vga16_text_fill_rect(vga,x+i*size, y+j*size, size, size, bg);
        }
      }
      line >>= 1;
    }
  }
}

void vga16_text_draw_char(vga16_text_t* vga, uint8_t c, color_t color, color_t bg, uint8_t size) {
    vga16_text_draw_char_interna( vga,vga->cursor_x, vga->cursor_y, c, color, bg, size);
}

uint16_t vga16_text_get_cursor_y(const vga16_text_t* vga) {
      return vga->cursor_y;
}

uint16_t vga16_text_get_cursor_x(const vga16_text_t* vga) {
      return vga->cursor_x;
}

uint8_t vga16_text_get_textsize(const vga16_text_t* vga) {
      return vga->textsize;
}

void vga16_text_set_text_cursor(vga16_text_t* vga, int16_t x, int16_t y) {
    vga->cursor_x = x;
    vga->cursor_y = y;
}

void vga16_text_set_text_size(vga16_text_t* vga, uint8_t s) {
    vga->textsize = (s > 0) ? s : 1;
}

void vga16_text_set_text_color(vga16_text_t* vga, color_t c) {
    vga->textcolor = c;
}

void vga16_text_set_text_color2(vga16_text_t* vga, color_t c, color_t b) {
    vga->textcolor   = c;
    vga->textbgcolor = b;
}

void vga16_text_set_text_wrap(vga16_text_t* vga, bool w) {
    vga->wrap = w;
}

void vga16_text_tft_write(vga16_text_t* vga, uint8_t c) {
  if (c == '\n') {
    vga->cursor_y += vga->textsize*8;
    vga->cursor_x  = 0;
  } else if (c == '\r') {
    // skip em
  } else if (c == '\t'){
      int new_x = vga->cursor_x + vga->tabspace;
      if (new_x < vga->width){
          vga->cursor_x = new_x;
      }
  } else {
    vga16_text_draw_char_interna(vga,vga->cursor_x, vga->cursor_y, c, vga->textcolor, vga->textbgcolor, vga->textsize);
    vga->cursor_x += vga->textsize*6;
    if (/*wrap &&*/ (vga->cursor_x > (vga->width - vga->textsize*6))) {
      vga->cursor_y += vga->textsize*8;
      vga->cursor_x = 0;
    }
  }
}

void vga16_text_print_string(vga16_text_t* vga, int8_t* str) {
    while (*str){
        vga16_text_tft_write(vga,*str++);
    }
}

void vga16_text_set_text_color_big(vga16_text_t* vga, color_t color, color_t background) {
    vga->textcolor   = color;
    vga->textbgcolor = background;
}

void vga16_text_write_string_bold(vga16_text_t* vga, int8_t* str) {
    char temp_bg ;
    temp_bg = vga->textbgcolor;
    while (*str){
        char c = *str++;
        vga16_text_draw_char_interna(vga,vga->cursor_x, vga->cursor_y, c, vga->textcolor, vga->textbgcolor, vga->textsize);
        vga16_text_draw_char_interna(vga,vga->cursor_x+1, vga->cursor_y, c, vga->textcolor, vga->textcolor, vga->textsize);
        vga->cursor_x += 7 * vga->textsize ;
    }
    vga->textbgcolor = temp_bg ;
}

color_t vga16_text_read_pixel(const vga16_text_t* vga, int16_t x, int16_t y) {
  int pixel = ((640 * y) + x) ;
  short color ;
  // Is this pixel stored in the first 4 bits
  // of the vga data array index, or the second
  // 4 bits? Check, then mask.
  if (pixel & 1) {
      color = vga->vga_data_array[pixel>>1] >> 4 ;
  }
  else {
      color = vga->vga_data_array[pixel>>1] & 0xf  ;
  }
  return color ;
}

// Métodos de acesso
uint16_t vga16_text_get_width(const vga16_text_t* vga) {
    return vga ? vga->width : 0;
}

uint16_t vga16_text_get_height(const vga16_text_t* vga) {
    return vga ? vga->height : 0;
}
